# ES6
> 来源：阮一峰大神的[es6入门](http://es6.ruanyifeng.com)

## let和const命令
### let

> let实际上为JavaScript新增了块级作用域。

* “暂时性死区”:在代码块内，使用let命令声明变量之前，变量不可用，会抛出一个ReferenceError。

### const

> const声明一个只读的常量。一旦声明，常量的值就不能改变。这意味着，const一旦声明变量，就必须立即初始化。

* 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。 
* 可以使用Object.freeze方法 将对象冻结。

3. 共性
* let和const命令都绑定了当前的块级作用域，变量不提升，存在暂时性死区，无法重复声明(也无法对函数参数重复声明)。
* let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。


## 变量的解构赋值
> 按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。

解构不成功，变量的值就等于undefined。
不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。

* 适用于var命令，let命令和const命令
* 解构赋值允许指定默认值。
* 解构赋值允许指定默认值，如果一个数组成员不严格等于undefined，默认值是不会生效的
* 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

### 默认值
* 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
* 默认值可以引用解构赋值的其他变量(引用的是赋值之后的其他变量)，但该变量必须已经声明。

### 数组的解构赋值  
* 如果等号的右边不是数组，或者严格地说，不是可遍历的结构，那么将会报错。
* 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。
* ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。

对于Set结构，也可以使用数组的解构赋值。
        
        let [x, y, z] = new Set(["a", "b", "c"]);
        x // "a"

### 对象的解构赋值  

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

* 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
* 变量没有对应的同名属性，导致取不到值，最后等于undefined。
* 默认值生效的条件是，对象的属性值严格等于undefined。

对象的解构赋值是下面形式的简写

        var { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
如果变量名与属性名不一致，必须写成下面这样
        
        var { foo: baz } = { foo: 'aaa', bar: 'bbb' };

### 字符串的解构赋值

字符串可以解构赋值是因为字符串被转换成了一个类似数组的对象。  
类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。

### 数值和布尔值的解构赋值

### 函数参数的解构赋值

### 作用
* 交换变量的值
* 从函数返回多个值
* 函数参数的定义
* 提取JSON数据
* 函数参数的默认值
* 遍历Map结构
* 输入模块的指定方法

## 字符串的扩展
### 字符串是否包含
includes()：返回布尔值，表示是否找到了参数字符串。  
startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。  
endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。  

### repeat方法  
返回一个新字符串，表示将原字符串重复n次。

### 字符串补全长度  
ES7推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart用于头部补全，padEnd用于尾部补全。

### 模板字符串
* 模板字符串的空格和换行，都是被保留，如果不想要这个换行，可以使用trim方法消除它。
* 模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。如果大括号内部是一个字符串，将会原样输出。
* 模板字符串之中还能调用函数。
* 模板字符串甚至还能嵌套。

## 正则的扩展

## 数值的扩展

## 数组的扩展
### Array.from()
> 用于将两类对象转为真正的数组：类似数组的对象（必须有length属性）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map） 

* 可以接受第二个参数，作用类似于数组的map方法  
* 可以将各种值转为真正的数组，并且还提供map功能 
* 将字符串转为数组，然后返回字符串的长度

e.g.

        
        let arrayLike = {
            '0': 'a',
            '1': 'b',
            '2': 'c',
            length: 3
        };
        // ES5的写法
        var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']
        // ES6的写法
        let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']

### Array.of() 
* 用于将一组数值，转换为数组。
* Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。

### 数组实例的copyWithin()
> 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。

target（必需）：从该位置开始替换数据。
start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。

### 数组实例的find()和findIndex()
> 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。

### 数组实例的fill()
> 使用给定值，填充一个数组，还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。

### 数组实例的entries()，keys()和values()
> 遍历数组，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。

## 函数的扩展
### 箭头函数
* 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
* 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。

### 函数参数的默认值

        // 写法一
        function m1({x = 0, y = 0} = {}) {
          return [x, y];
        }
        // 写法二
        function m2({x, y} = { x: 0, y: 0 }) {
          return [x, y];
        }

上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。

### length属性  
指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。

### 默认值参数作用域
如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。

利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。

### rest参数 
> ES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

* rest参数之后不能再有其他参数
* 函数的length属性，不包括rest参数

### 扩展运算符
扩展运算符（spread）是三个点（...）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。
* 替代数组的apply方法
* 合并数组
* 与解构赋值结合(如果将扩展运算符用于数组赋值，只能放在参数的最后一位)
* 函数的返回值
** JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。
* 字符串
** 扩展运算符还可以将字符串转为真正的数组。
* 实现了Iterator接口的对象
* Map和Set结构，Generator函数

### name属性

## 对象的扩展
### 属性名和方法名简洁表示法、属性名表达式、方法的name属性

### Object.is()

### Object.assign() 
> 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）

* 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
* 如果该参数不是对象，则会先转成对象。
* 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。
* 如果非对象参数出现在源对象的位置（即非首参数），这些参数都会转成对象，如果无法转成对象，就会跳过。
* Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。
* 属性名为Symbol值的属性，也会被Object.assign拷贝。

Object.assign方法实行的是浅拷贝

## Symbol










