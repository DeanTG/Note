# ES6
> 来源：阮一峰大神的[es6入门](http://es6.ruanyifeng.com)

## let和const命令
### let

> let实际上为JavaScript新增了块级作用域。

* “暂时性死区”:在代码块内，使用let命令声明变量之前，变量不可用，会抛出一个ReferenceError。

### const

> const声明一个只读的常量。一旦声明，常量的值就不能改变。这意味着，const一旦声明变量，就必须立即初始化。

* 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。 
* 可以使用Object.freeze方法 将对象冻结。

3. 共性
* let和const命令都绑定了当前的块级作用域，变量不提升，存在暂时性死区，无法重复声明(也无法对函数参数重复声明)。
* let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。


## 变量的解构赋值
> 按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。

解构不成功，变量的值就等于undefined。
不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。

* 适用于var命令，let命令和const命令
* 解构赋值允许指定默认值。
* 解构赋值允许指定默认值，如果一个数组成员不严格等于undefined，默认值是不会生效的
* 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

### 默认值
* 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
* 默认值可以引用解构赋值的其他变量(引用的是赋值之后的其他变量)，但该变量必须已经声明。

### 数组的解构赋值  
* 如果等号的右边不是数组，或者严格地说，不是可遍历的结构，那么将会报错。
* 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。
* ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。

对于Set结构，也可以使用数组的解构赋值。
        
        let [x, y, z] = new Set(["a", "b", "c"]);
        x // "a"

### 对象的解构赋值  

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

* 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
* 变量没有对应的同名属性，导致取不到值，最后等于undefined。
* 默认值生效的条件是，对象的属性值严格等于undefined。

对象的解构赋值是下面形式的简写

        var { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
如果变量名与属性名不一致，必须写成下面这样
        
        var { foo: baz } = { foo: 'aaa', bar: 'bbb' };

### 字符串的解构赋值

字符串可以解构赋值是因为字符串被转换成了一个类似数组的对象。  
类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。

### 数值和布尔值的解构赋值

### 函数参数的解构赋值

### 作用
* 交换变量的值
* 从函数返回多个值
* 函数参数的定义
* 提取JSON数据
* 函数参数的默认值
* 遍历Map结构
* 输入模块的指定方法

## 字符串的扩展
### 字符串是否包含
includes()：返回布尔值，表示是否找到了参数字符串。  
startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。  
endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。  

### repeat方法  
返回一个新字符串，表示将原字符串重复n次。

### 字符串补全长度  
ES7推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart用于头部补全，padEnd用于尾部补全。

### 模板字符串
* 模板字符串的空格和换行，都是被保留，如果不想要这个换行，可以使用trim方法消除它。
* 模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。如果大括号内部是一个字符串，将会原样输出。
* 模板字符串之中还能调用函数。
* 模板字符串甚至还能嵌套。

## 正则的扩展

## 数值的扩展

## 数组的扩展
### Array.from()
> 用于将两类对象转为真正的数组：类似数组的对象（必须有length属性）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map） 

* 可以接受第二个参数，作用类似于数组的map方法  
* 可以将各种值转为真正的数组，并且还提供map功能 
* 将字符串转为数组，然后返回字符串的长度

e.g.

        
        let arrayLike = {
            '0': 'a',
            '1': 'b',
            '2': 'c',
            length: 3
        };
        // ES5的写法
        var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']
        // ES6的写法
        let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']

### Array.of() 
* 用于将一组数值，转换为数组。
* Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。

### 数组实例的copyWithin()
> 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。

target（必需）：从该位置开始替换数据。
start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。

### 数组实例的find()和findIndex()
> 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。

### 数组实例的fill()
> 使用给定值，填充一个数组，还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。

### 数组实例的entries()，keys()和values()
> 遍历数组，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。

## 函数的扩展
### 箭头函数
* 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
* 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。

### 函数参数的默认值

        // 写法一
        function m1({x = 0, y = 0} = {}) {
          return [x, y];
        }
        // 写法二
        function m2({x, y} = { x: 0, y: 0 }) {
          return [x, y];
        }

上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。

### length属性  
指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。

### 默认值参数作用域
如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。

利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。

### rest参数 
> ES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

* rest参数之后不能再有其他参数
* 函数的length属性，不包括rest参数

### 扩展运算符
扩展运算符（spread）是三个点（...）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。
* 替代数组的apply方法
* 合并数组
* 与解构赋值结合(如果将扩展运算符用于数组赋值，只能放在参数的最后一位)
* 函数的返回值
** JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。
* 字符串
** 扩展运算符还可以将字符串转为真正的数组。
* 实现了Iterator接口的对象
* Map和Set结构，Generator函数

### name属性

## 对象的扩展
### 属性名和方法名简洁表示法、属性名表达式、方法的name属性

### Object.is()

### Object.assign() 
> 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）

* 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
* 如果该参数不是对象，则会先转成对象。
* 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。
* 如果非对象参数出现在源对象的位置（即非首参数），这些参数都会转成对象，如果无法转成对象，就会跳过。
* Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。
* 属性名为Symbol值的属性，也会被Object.assign拷贝。

Object.assign方法实行的是浅拷贝

### 属性的可枚举性
ES6规定，所有Class的原型的方法都是不可枚举的。

### 属性的遍历
* for...in
* Object.keys(obj)
* Object.getOwnPropertyNames(obj)
* Object.getOwnPropertySymbols(obj)
* Reflect.ownKeys(obj)

首先遍历所有属性名为数值的属性，按照数字排序。
其次遍历所有属性名为字符串的属性，按照生成时间排序。
最后遍历所有属性名为Symbol值的属性，按照生成时间排序。

### __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()

### Object.values()，Object.entries() 

### 对象的扩展运算符
解构赋值的拷贝是浅拷贝，解构赋值不会拷贝继承自原型对象的属性。

### Object.getOwnPropertyDescriptors()

## Symbol
> Symbol值不是对象，所以不能添加属性，它是一种类似于字符串的数据类型

Symbol值不能与其他类型的值进行运算，Symbol值可以显式转为字符串，也可以转为布尔值。

由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。

### Symbol.for()，Symbol.keyFor()
我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。

Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。

Symbol.for为Symbol值登记的名字，是全局环境的，可以在不同的iframe或service worker中取到同一个值

## Proxy

## Reflect

## Set
> ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set数据结构。

## Map

## Generator 函数
> 从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。

## Promise
> Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。

### then方法
then方法返回的是一个新的Promise实例（不是原来那个Promise实例）。

then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。

### catch方法
> Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。catch方法返回的还是一个Promise对象

Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。

### Promise.all()
Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。

Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。

### Promise.race()
Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。

### Promise.resolve()
> 将现有对象转为Promise对象

### Promise.reject() 

## Class
类的数据类型就是函数，类本身就指向构造函数

由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。

类的内部所有定义的方法，都是不可枚举的（non-enumerable）

一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。

constructor方法默认返回实例对象（即this）。

### 类的实例对象
实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。

### 私有方法

        class Widget {
          foo (baz) {
            bar.call(this, baz);
          }
          // ...
        }
        function bar(baz) {
          return this.snaf = baz;
        }

还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。

        const bar = Symbol('bar');
        const snaf = Symbol('snaf');
        export default class myClass{
          // 公有方法
          foo(baz) {
            this[bar](baz);
          }
          // 私有方法
          [bar](baz) {
            return this[snaf] = baz;
          }
          // ...
        };

考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。

### Class的继承
super关键字表示父类的构造函数，用来新建父类的this对象。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。

### 类的prototype属性和__proto__属性
1. 子类的__proto__属性，表示构造函数的继承，总是指向父类。
2. 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。

### super关键字
第一种情况，super作为函数调用时，代表父类的构造函数。
第二种情况，super作为对象时，指向父类的原型对象。由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。

### Class的静态方法
类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。

父类的静态方法，可以被子类继承。

### Mixin模式的实现




